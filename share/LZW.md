# 怎么读数据

一个字符可以看作是 8 位的 2 进制数字，比如 '10101010'，那么字符串就可以看作连续的 2 进制，比如 '10101010','10101011'。

读数据的参数是一个【代码位数】的值，这个值是一个 1 ～ 12 的数字。

比如我第一次读 5 位，第二次读 8 位，那就是 '10101' 和 '01010101'

# 词典表和输出结果

- 词典表

```ts
[[0], [1], [2], ..., [254], [255], [], null] // 词典表的样子
```

词典表里的每一项看作是一个单词，单词里每个数字看作是字母。

- 【输出结果】

```ts
[0,0,0,255,255,255,...]
```

在 GIF89a 里，输出结果的内容是图片的像素颜色集合，每 3 位是一个 rgb

# 解压缩算法的变量

1. 参数：

   - 【初始代码位数】：表示下一个【代码】是几位
   - 【源数据】图像压缩数据

2. 变量

- 【代码位数】[1, 12] 表示下一个【代码】是几位的二进制，如果【词典表】长度达到【代码位数】允许的最大值，那么【代码位数】会自增。
- 【代码】遍历【源数据】读取代码，然后根据【代码】的值做出对【词典表】的策略

# 解压缩策略

0. 构造原始词典表
1. 根据【代码位数】不断从【源数据】读取读取【代码】
   - 如果【代码】值是【清除码(固定值是 1 << 【初始代码位数】)】，意味着当前词典表和后续内容没关系了，应该重置词典表
2. 根据【代码】做出策略
   - 如果【代码】值是【结束码(固定值是【清除码】+1)】，意味着解压缩结束，输出结果
   - 如果【代码】不是【结束码】也不是【清除码】，那么构造新单词并添加到词典表。
     > 新单词是上一个【代码】索引的单词+当前【代码】索引单词的首字母，如果当前【代码】索引没有单词，取上一个【代码】索引单词的首字母
3. 从词典表里取【代码】索引的单词，添加到输出结果中

# 假设示例
- 假设接参【初始代码位数】是8
- 构造原始词典表
```ts
[[0], [1], [2], ..., [254], [255], [], null]
```
- 假如读取【代码】是256
- 重置词典表，跳过当前循环
> 策略循环
- 假如读取【代码】是0
- 由于上一次读到的是清除码，所以没有上一个单词，跳过构造新单词
- 从【代码】0位取单词 [0]，添加到结果
> 策略循环
- 假如读取【代码】是258
- 上一个单词是 [0]，然后这次258刚好是词典表长度，没读到单词，所以新字母是上一个单词的首字母 0，所以新单词是 [0, 0]，添加到词典表里
- 从【代码】258位取单词 [0, 0]，添加到结果
> 策略循环
- ...直到读取的【代码】是结束码时，返回结果


